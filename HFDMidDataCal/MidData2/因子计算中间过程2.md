# 因子计算中间数据说明文档

- 如果不做特殊说明，所有数据的计算都不包含集合竞价数据
- 日内数据第一根K线为09:30:00，最后一根K线为15:00:00
- 对于深度数据的统计，默认剔除14:57:00到15:00:00的数据，方便统计

### 时间区间

- close_price = {
    '0h': '09:30:00',
    '0.5h': '10:00:00',
    '1h': '10:30:00',
    '1.5h': '11:00:00',
    '2h': '11:30:00',
    '2.5h': '13:30:00',
    '3h': '14:00:00',
    '3.5h': '14:30:00',
    '4h': '15:00:00'
}

- time_AM = {
    "call": "09:30:00",
    "5min": "09:35:00",
    "10min": "09:40:00",
    "15min": "09:45:00",
    "30min": "10:00:00",
    "60min": "10:30:00",
    "all": "11:30:00"
}
    
- time_PM = {
    "5min": "14:55:00",
    "10min": "14:50:00",
    "15min": "14:45:00",
    "30min": "14:30:00",
    "60min": "14:00:00",
    "all": "13:00:00"
}
    
- time_std = {
    "all": ["09:30:00", "15:00:00"],
    "open": ["09:30:00", "10:00:00"],
    "between": ["10:00:00", "14:30:00"],
    "close": ["14:30:00", "15:00:00"]
}

### 字段说明和对应的代码

#### 特殊函数说明：

- range_T:日内成交数据切片

````
def range_T(self, data: pd.DataFrame):
    return (data['time'] >= '09:30:00') & (data['time'] < '15:00:00')
````

#### 1.收益相关数据

数据存储文件:TradeRet.csv

字段说明
- retDiffMean:收益率差分均值
- retDiffAbsMean:收益率差分绝对值均值

- retMean:收益率均值
- retAbsMean:收益率绝对值均值

- ret2Up_0:收益率大于0的平方和
- ret2Down_0:收益率小于0的平方和
- ret3Up_0:收益率大于0的三次方和
- ret3Down_0:收益率小于0的三次方和

- retVolWeight:成交量加权收益

- retVar:收益率方差
- retSkew:收益率偏度
- retKurt:收益率峰度

- date:日期

对应代码
````
def _trade_ret(self, d: pd.DataFrame, date: str) -> pd.Series:
    d_sub = d[self.range_T]
    d_sub['ret'] = d_sub['close'].pct_change()

    retDiff = d_sub['ret'].diff(1)
    retData = {
        "retDiffMean": retDiff.mean(),  # 收益率差分均值
        "retDiffAbsMean": abs(retDiff).mean(),  # 收益率差分绝对值均值

        "retMean": d_sub['ret'].mean(),  # 收益率均值
        "retAbsMean": abs(d_sub['ret']).mean(),  # 收益率绝对值均值

        "ret2Up_0": pow(d_sub['ret'][d_sub['ret'] > 0], 2).sum(),  # 收益率大于0的平方和
        "ret2Down_0": pow(d_sub['ret'][d_sub['ret'] < 0], 2).sum(),  # 收益率小于0的平方和

        "ret3Up_0": pow(d_sub['ret'][d_sub['ret'] > 0], 3).sum(),  # 收益率大于0的三次方和
        "ret3Down_0": pow(d_sub['ret'][d_sub['ret'] < 0], 3).sum(),  # 收益率小于0的三次方和

        "retVolWeight": (d_sub['ret'] * d_sub['volume']).sum() / d_sub['volume'].sum(),  # 成交量加权收益

        "retVar": d_sub['ret'].var(),  # 收益率方差
        "retSkew": d_sub['ret'].skew(),  # 收益率偏度
        "retKurt": d_sub['ret'].kurt(),  # 收益率峰度

        "date": date
    }
    return pd.Series(retData)
````

#### 2.成交量相关数据

数据存储文件:TradeVol.csv

字段说明

- volDiffMean：成交量差分均值
- volDiffStd：成交量差分标准差

- volDiffAbsMean：成交量差分绝对值均值
- volDiffAbsStd：成交量差分绝对值标准差

- volPerMean：每笔成交量均值
- volPerStd：每笔成交量标准差

- volPerDiffMean：每笔成交量差分均值
- volPerDiffStd：每笔成交量差分标准差

- volPerDiffAbsMean：每笔成交量差分绝对值均值
- volPerDiffAbsStd：每笔成交量差分绝绝对值标准差

- date：日期

对应代码
````
def _trade_vol(self, d: pd.DataFrame, date: str) -> pd.Series:

    d['volPerTrade'] = d['volume'] / d['tradenum']
    d_sub = d[self.range_T]

    volDiff = d_sub['volume'].diff(1)
    volPerDiff = d_sub['volPerTrade'].diff(1)

    vol_data = pd.Series({

        "volDiffMean": volDiff.mean(),  # 成交量差分均值
        "volDiffStd": volDiff.std(),  # 成交量差分标准差

        "volDiffAbsMean": abs(volDiff).mean(),  # 成交量差分绝对值均值
        "volDiffAbsStd": abs(volDiff).std(),  # 成交量差分绝对值标准差

        "volPerMean": d_sub['volPerTrade'].mean(),  # 每笔成交量均值
        "volPerStd": d_sub['volPerTrade'].std(),  # 每笔成交量标准差

        "volPerDiffMean": volPerDiff.mean(),  # 每笔成交量差分均值
        "volPerDiffStd": volPerDiff.std(),  # 每笔成交量差分标准差

        "volPerDiffAbsMean": abs(volPerDiff).mean(),  # 每笔成交量差分绝对值均值
        "volPerDiffAbsStd": abs(volPerDiff).std(),  # 每笔成交量差分绝绝对值标准差

        "date": date
    })
    return pd.Series(vol_data)
````

#### 3.成交笔数相关数据

数据存储文件:TradeTradeNum.csv

字段说明
- tradeNumRetUpSum_0:收益率大于0的笔数和
- tradeNumRetDownSum_0:收益率小于0的笔数和
- tradeNumRetEqualSum_0:收益率等于0的笔数和

- tradeNumDiffMean:成交笔数差分均值
- tradeNumDiffStd:成交笔数差分标准差

- tradeNumDiffAbsMean:成交笔数差分绝对值均值
- tradeNumDiffAbsStd:成交笔数差分绝对值标准差

- date:日期
对应代码
````
def _trade_trade_num(self, d: pd.DataFrame, date: str) -> pd.Series:
    d_sub = d[self.range_T]
    d_sub['ret'] = d_sub['close'].pct_change()

    tradeNumDiff = d_sub['tradenum'].diff(1)

    tradeNumData = {
        "tradeNumRetUpSum_0": d_sub[d_sub['ret'] > 0]['tradenum'].sum(),  # 收益率大于0的笔数和
        "tradeNumRetDownSum_0": d_sub[d_sub['ret'] < 0]['tradenum'].sum(),  # 收益率小于0的笔数和
        "tradeNumRetEqualSum_0": d_sub[np.isnan(d_sub['ret']) | (d_sub['ret'] == 0)]['tradenum'].sum(),  # 收益率等于0的笔数和(包含收益率为空的数据)

        "tradeNumDiffMean": tradeNumDiff.mean(),  # 成交笔数差分均值
        "tradeNumDiffStd": tradeNumDiff.std(),  # 成交笔数差分标准差

        "tradeNumDiffAbsMean": abs(tradeNumDiff).mean(),  # 成交笔数差分绝对值均值
        "tradeNumDiffAbsStd": abs(tradeNumDiff).std(),  # 成交笔数差分绝对值标准差

        "date": date  # 日期
    }
    return pd.Series(tradeNumData)
````

#### 4.成不同时间段总成交额和数据

数据存储文件:TradeAmtSum.csv

字段说明
- amtAM_x:开盘不同时间段成交量和(amtAM_5min:开盘5分钟成交量和)
- amtPM_x:尾盘不同时间段成交量和(amtPM_5min:尾盘5分钟成交量和)

- amtRetUpSum_0:收益率大于0的成交额和
- amtRetDownSum_0:收益率小于0的成交额和
- amtRetEqualSum_0:收益率等于0的成交额和

- date:日期

对应代码
````
def _trade_amt_sum(self, d: pd.DataFrame, date: str) -> pd.Series:
    d_sub = d[self.range_T]
    d_sub['ret'] = d_sub['close'].pct_change()

    amtSumAM = {f"amtAM_{time_}": d[d['time'] < right_time]['amount'].sum()
                for time_, right_time in self.time_AM.items()}  # 开盘不同时间段成交量和

    amtSumPM = {f"amtPM_{time_}": d[d['time'] >= left_time]['amount'].sum()
                for time_, left_time in self.time_PM.items()}  # 尾盘不同时间段成交量和

    amtSumSp = {
        "amtRetUpSum_0": d_sub[d_sub['ret'] > 0]['amount'].sum(),  # 收益率大于0的成交额和
        "amtRetDownSum_0": d_sub[d_sub['ret'] < 0]['amount'].sum(),  # 收益率小于0的成交额和
        "amtRetEqualSum_0": d_sub[np.isnan(d_sub['ret']) | (d_sub['ret'] == 0)]['amount'].sum(),  # # 收益率等于0的成交额和
        "date": date  # 日期
    }

    amtSum = dict(**amtSumAM, **amtSumPM, **amtSumSp)
    return pd.Series(amtSum)
````

#### 5.不同时间段主买额和数据

数据存储文件:TradeBuyAmtSum.csv

字段说明

- buyAmtSumAM_x:开盘不同时间段主买额和(buyAmtSumAM_5min:开盘5分钟主买额和)
- buyAmtSumPM_x:尾盘不同时间段主买额和(buyAmtSumPM_5min:尾盘5分钟主买额和)

- date:日期

对应代码
````
def _trade_buy_amt_sum(self, d: pd.DataFrame, date: str) -> pd.Series:
    buyAmtSumAM = {f"buyAmtSumAM_{t_}": d[d['time'] < T_r]['buyamount'].sum()
                   for t_, T_r in self.time_AM.items()}  # 开盘不同时间段主买额和

    buyAmtSumPM = {f"buyAmtSumPM_{t_}": d[d['time'] >= T_l]['buyamount'].sum()
                   for t_, T_l in self.time_PM.items()}  # 尾盘不同时间段主买额和

    buyAmtSum = dict(**buyAmtSumAM, **buyAmtSumPM, **{"date": date})

    return pd.Series(buyAmtSum)
````

#### 6.不同时间段主卖额和数据

数据存储文件:TradeSellAmtSum.csv

字段说明

- sellAmtSumAM_x:开盘不同时间段主卖额和(sellAmtSumAM_5min:开盘5分钟主卖额和)
- sellAmtSumPM_x:尾盘不同时间段主卖额和(sellAmtSumPM_5min:尾盘5分钟主卖额和)

- date:日期

对应代码
````
def _trade_sell_amt_sum(self, d: pd.DataFrame, date: str) -> pd.Series:
    d['sellAmount'] = d['amount'] - d['buyamount']

    sellAmtSumAM = {f"sellAmtSumAM_{t_}": d[d['time'] < T_r]['sellAmount'].sum()
                    for t_, T_r in self.time_AM.items()}  # 开盘不同时间段主卖额和

    sellAmtSumPM = {f"sellAmtSumPM_{t_}": d[d['time'] >= T_l]['sellAmount'].sum()
                    for t_, T_l in self.time_PM.items()}  # 尾盘不同时间段主卖额和

    sellAmtSum = dict(**sellAmtSumAM, **sellAmtSumPM, **{"date": date})

    return pd.Series(sellAmtSum)
````

#### 7.不同时间段成交额标准差数据

数据存储文件:TradeAmtStd.csv

字段说明

- buyAmtStd_x:不同时间段主买额标准差(sellAmtSumAM_open:开盘阶段主买额标准差)
- sellAmtStd_x:不同时间段主卖额标准差(sellAmtStd_open:开盘阶段主卖额标准差)
- netAmtStd_x:不同时间段净主买额标准差(netAmtStd_open:开盘阶段净主买额标准差)

- amtStd_x:不同时间段成交额标准差(amtStd_open:开盘阶段成交额标准差)

- date:日期

对应代码
````
def _trade_amt_std(self, d: pd.DataFrame, date: str) -> pd.Series:
    d['sellAmount'] = d['amount'] - d['buyamount']

    buyAmtStd = {f"buyAmtStd_{t_}": d[(d['time'] >= T_[0]) & (d['time'] < T_[1])]['buyamount'].std()
                 for t_, T_ in self.time_std.items()}  # 不同时间段主买额标准差
    sellAmtStd = {f"sellAmtStd_{t_}": d[(d['time'] >= T_[0]) & (d['time'] < T_[1])]['sellAmount'].std()
                  for t_, T_ in self.time_std.items()}  # 不同时间段主卖额标准差
    netAmtStd = {f"netAmtStd_{t_}": d[(d['time'] >= T_[0]) & (d['time'] < T_[1])]['netAmount'].std()
                 for t_, T_ in self.time_std.items()}  # 不同时间段净主买额标准差

    allAmtAtd = {f"amtStd_{t_}": d[(d['time'] >= T_[0]) & (d['time'] < T_[1])]['amount'].std()
                 for t_, T_ in self.time_std.items()}  # 不同时间段成交额标准差

    amtStd = dict(**buyAmtStd, **sellAmtStd, **allAmtAtd, **netAmtStd, **{"date": date})
    return pd.Series(amtStd)
````

#### 8.收盘价相关中间数据

数据存储文件:TradeClose.csv

字段说明

- closeX:不同时间截面收盘价(close0.5h:上午10点收盘价)
- closeMean:收盘价均值
- closeStd:收盘价标准差
- closeAmtWeight:成交量加权收盘价

- date:日期

对应代码
````
def _trade_close(self, d: pd.DataFrame, date: str) -> pd.Series:
    d_sub = d[self.range_T]

    # 收盘价相关中间过程
    closeData = {"close" + t_: 0 if d[d['time'] <= T_r].tail(1)['close'].empty
    else d[d['time'] <= T_r].tail(1)['close'].values[0]
                 for t_, T_r in self.close_price.items()}  # 不同时间截面收盘价

    closeData.update({
        "closeMean": d_sub['close'].mean(),  # 收盘价均值
        "closeStd": d_sub['close'].std(),  # 收盘价标准差
        "closeAmtWeight": (d_sub['close'] * d_sub['amount']).sum() / d_sub['amount'].sum(),  # 成交量加权收盘价
        "date": date  # 日期
    })
    return pd.Series(closeData)
````

#### 9.特殊因子1数据

数据存储文件:TradeSpecial1.csv

字段说明

- corCloseVol:收盘价和成交量pearson相关系数
- corRetVol:收益率和成交量pearson相关系数

- closeVolWeightSkew:加权收盘价偏度

- AMTInFlowBigOrder:单笔成交量在前20%的成交量收益率大于零的和(大单流入)
- AMTOutFlowBigOrder:单笔成交量在前20%的成交量收益率小于零的和(大单流出)

- CashFlow:资金流向(成交量加权收盘价差分和)

- MOMBigOrder:大单驱动涨幅

- retD:轨迹非流动因子分母

- RevStruct:结构化反转因子

- date:日期

对应代码
````
def _trade_special1(self, d: pd.DataFrame, date: str) -> pd.Series:
    d['amtPerTrade'] = d['amount'] / d['tradenum']
    d_sub = d[self.range_T]
    d_sub['ret'] = d_sub['close'].pct_change()

    d_sub1 = d_sub[d_sub['amtPerTrade'] >= d_sub['amtPerTrade'].quantile(0.8)]
    d_sub_inflow, d_sub_outflow = d_sub1[d_sub1['ret'] > 0], d_sub1[d_sub1['ret'] < 0]

    specialData = {
        "corCloseVol": d_sub[['close', 'volume']].corr().iloc[0, 1],  # 收盘价和成交量pearson相关系数
        "corRetVol": d_sub[['ret', 'volume']].corr().iloc[0, 1],  # 收益率和成交量pearson相关系数

        "closeVolWeightSkew": (pow((d_sub['close'] - d_sub['close'].mean()) / d_sub['close'].std(), 3) * (
                d_sub['volume'] / d_sub['volume'].sum())).sum(),  # 加权收盘价偏度

        "AMTInFlowBigOrder": d_sub_inflow['amount'].sum(),  # 单笔成交量在前20%的成交量收益率大于零的和(大单流入)
        "AMTOutFlowBigOrder": d_sub_outflow['amount'].sum(),  # 单笔成交量在前20%的成交量收益率小于零的和(大单流出)

        "CashFlow": (np.sign(d_sub['close'].diff(1)) * d_sub['amount']).sum() / d_sub['amount'].sum(),
        # 资金流向(成交量加权收盘价差分和)

        "MOMBigOrder": (d_sub[d_sub['amtPerTrade'] >= d_sub['amtPerTrade'].quantile(0.8)]['ret'] + 1).prod(
            min_count=1),  # 大单驱动涨幅

        "retD": np.log(1 + abs(np.log(d_sub['close'] / d_sub['close'].shift(1)))).sum(),
        # 轨迹非流动因子分母
        "RevStruct": func_Structured_reversal(d_sub, 0.1),  # 结构化反转因子

        "date": date  # 日期
    }
    return pd.Series(specialData)
````

#### 10.特殊因子2数据

数据存储文件:TradeSpecial2.csv

字段说明

- volEntropy:单位一成交量占比熵
- amtEntropy:成交额占比熵

- naiveAmtR:朴素主动占比因子
- TAmtR:T分布主动占比因子
- NAmtR:正态分布主动占比因子
- CNAmtR:置信正态分布主动占比因子
- EventAmtR:均匀分布主动占比因子

- SmartQ:聪明钱因子
- SmartQln:聪明钱因子改进

- date:日期

对应代码
````
def _trade_special2(self, d: pd.DataFrame, date: str) -> pd.Series:
    d_sub = d[self.range_T]
    d_sub['ret'] = d_sub['close'].pct_change()

    specialData = {
        "volEntropy": entropy(d_sub['close'] * d_sub['volume']),  # 单位一成交量占比熵
        "amtEntropy": entropy(d_sub['amount']),  # 成交额占比熵

        "naiveAmtR": (st.t.cdf(d_sub['close'].diff(1) / d_sub['close'].diff(1).std(), len(d_sub) - 1) * d_sub[
            'amount']).sum() / d_sub['amount'].sum(),  # 朴素主动占比因子
        "TAmtR": (st.t.cdf(d_sub['ret'] / d_sub['ret'].std(), len(d_sub) - 1) * d_sub['amount']).sum() / d_sub[
            'amount'].sum(),  # T分布主动占比因子
        "NAmtR": (st.norm.cdf(d_sub['ret'] / d_sub['ret'].std()) * d_sub['amount']).sum() / d_sub['amount'].sum(),  # 正态分布主动占比因子
        "CNAmtR": (st.norm.cdf(d_sub['ret'] / 0.1 * 1.96) * d_sub['amount']).sum() / d_sub['amount'].sum(),  # 置信正态分布主动占比因子
        "EventAmtR": ((d_sub["ret"] - 0.1) / 0.2 * d_sub['amount']).sum() / d_sub['amount'].sum(),  # 均匀分布主动占比因子

        "SmartQ": func_M_sqrt(d_sub),  # 聪明钱因子
        "SmartQln": func_M_ln(d_sub),  # 聪明钱因子改进

        "date": date  # 日期
    }
    return pd.Series(specialData)
````

#### 11.不同时间点5档口委买委卖量和数据

数据存储文件:Depth5VolSum.csv

字段说明

- bid5VolSum_x:不同时间点5挡委买量和(bid5VolSum_1h:10点半5挡盘口委买量和)
- ask5VolSum_x:不同时间点5挡委卖量和(ask5VolSum_1h:10点半5挡盘口委卖量和)

- date:日期

对应代码
````
def _depth5_vol_sum(self, data: pd.DataFrame, date: str) -> pd.Series:
    bidvolume5 = [f'bidvolume{i}' for i in range(1, 6)]
    askvolume5 = [f'askvolume{i}' for i in range(1, 6)]

    bid5VolSum = {f"bid5VolSum_{t_}": np.array(data[data['time'] <= T_r][bidvolume5].tail(1)).sum()
                  for t_, T_r in self.close_price.items()}  # 不同时间点5挡委买量和
    ask5VolSum = {f"ask5VolSum_{t_}": np.array(data[data['time'] <= T_r][askvolume5].tail(1)).sum()
                  for t_, T_r in self.close_price.items()}  # 不同时间点5挡委卖量和

    bidAsk5Sum = dict(**bid5VolSum, **ask5VolSum, **{"date": date})
    # 去除4小时数据
    bidAsk5Sum.pop('bid5VolSum_4h'), bidAsk5Sum.pop('ask5VolSum_4h')

    return pd.Series(bidAsk5Sum)
````

#### 12.不同时间点10档口委买委卖量和数据

数据存储文件:Depth5VolSum.csv

字段说明

- bid105VolSum_x:不同时间点5挡委买量和(bid5VolSum_1h:10点半10挡盘口委买量和)
- ask10VolSum_x:不同时间点5挡委卖量和(ask5VolSum_1h:10点半10挡盘口委卖量和)

- date:日期

对应代码
````
def _depth10_vol_sum(self, data: pd.DataFrame, date: str) -> pd.Series:
    bidvolume10 = [f'bidvolume{i}' for i in range(1, 11)]
    askvolume10 = [f'askvolume{i}' for i in range(1, 11)]

    bid10VolSum = {f"bid10VolSum_{t_}": np.array(data[data['time'] <= T_r][bidvolume10].tail(1)).sum()
                   for t_, T_r in self.close_price.items()}  # 不同时间点10挡委买量和
    ask10VolSum = {f"ask10VolSum_{t_}": np.array(data[data['time'] <= T_r][askvolume10].tail(1)).sum()
                   for t_, T_r in self.close_price.items()}  # 不同时间点10挡委卖量和

    askBid10Sum = dict(**bid10VolSum, **ask10VolSum, **{"date": date})
    # 去除4小时数据
    askBid10Sum.pop('bid10VolSum_4h'), askBid10Sum.pop('ask10VolSum_4h')

    return pd.Series(askBid10Sum)
````

#### 静态函数
- entropy: 离散熵的计算
- func_M_sqrt：聪明钱因子计算过程
- func_M_ln： 改进的聪明钱因子计算过程
- func_Structured_reversal： 结构化反转因子计算过程


````
def entropy(x: pd.Series, bottom: int = 2):
    """
    离散熵
    空值不剔除
    :param x:
    :param bottom:
    :return:
    """
    Probability = (x.groupby(x).count()).div(len(x))
    log2 = np.log(Probability) / np.log(bottom)
    result = - (Probability * log2).sum()
    return result


def func_M_sqrt(data: pd.DataFrame):

    # 可能存在分钟线丢失
    data['S'] = abs(data['close'].pct_change()) / np.sqrt(data['volume'])
    VWAP = (data['close'] * data['volume'] / (data['volume']).sum()).sum()
    data = data.sort_values('S', ascending=False)
    data['cum_volume_R'] = data['volume'].cumsum() / (data['volume']).sum()
    data_ = data[data['cum_volume_R'] <= 0.2]
    res = (data_['close'] * data_['volume'] / (data_['volume']).sum()).sum() / VWAP

    return res


def func_M_ln(data: pd.DataFrame):

    data['S'] = abs(data['close'].pct_change()) / np.log(data['volume'])
    VWAP = (data['close'] * data['volume'] / (data['volume']).sum()).sum()
    data = data.sort_values('S', ascending=False)
    data['cum_volume_R'] = data['volume'].cumsum() / (data['volume']).sum()
    data_ = data[data['cum_volume_R'] <= 0.2]
    res = (data_['close'] * data_['volume'] / (data_['volume']).sum()).sum() / VWAP
    return res


def func_Structured_reversal(data: pd.DataFrame,
                             ratio: float):

    data = data.sort_values('volume', ascending=True)
    data['cum_volume'] = data['volume'].cumsum() / data['volume'].sum()
    # momentum
    data_mom = data[data['cum_volume'] <= ratio]
    rev_mom = (data_mom['ret'] * (1 / data_mom['volume'])).sum() / (1 / data_mom['volume']).sum()
    # Reverse
    data_rev = data[data['cum_volume'] > ratio]
    rev_rev = (data_rev['ret'] * (data_rev['volume'])).sum() / (data_rev['volume']).sum()

    rev_struct = rev_rev - rev_mom
    if np.isnan(rev_struct):
        print("Nan error!")
    return rev_struct